std::string GetThreadName(int threadId, const std::string& statusPath) {
    std::ifstream statusFile(statusPath);
    std::string line;
    while (std::getline(statusFile, line)) {
    if (line.find("Name:") == 0) {
            std::istringstream iss(line);
            std::string name;
            iss >> name >> std::ws;
            std::getline(iss, name);
            return name;
    }
    }
    return "";
}

int GetThreadPriority(int pid, int tid) {
    std::string statPath = "/proc/" + std::to_string(pid) + "/task/" + std::to_string(tid) + "/stat";
    std::ifstream statFile(statPath);
    std::string line;

    while (std::getline(statFile, line)) {
    if (line.find(") ") != std::string::npos) {
            std::istringstream iss(line.substr(line.find(") ") + 2)); // Skip the part before and including the first ")"

            // Fields 18 and 19 in the stat file represent "nice" and "priority"
            int nice, priority;
            for (int i = 0; i < 15; ++i) {
                iss.ignore(std::numeric_limits<std::streamsize>::max(), ' '); // Ignore preceding fields
            }
            iss >> priority >> nice;

            return nice;
    }
    }

    return 0; // Default value if thread priority information is not found
}


long getThreadCpuTime(int pid, int tid) {
    std::ifstream statFile("/proc/" + std::to_string(pid) + "/task/" + std::to_string(tid) + "/stat");

    if (!statFile.is_open()) {
    std::cerr << "Error opening stat file for thread " << tid << std::endl;
    return -1;
    }

    // Read the contents of the stat file
    std::string line;
    std::getline(statFile, line);

    // Extract the 14th and 15th fields from the stat file, which represent utime and stime
    std::istringstream iss(line);
    long utime, stime, cutime, cstime;

    for (int i = 0; i < 13; ++i) {
    while (iss.get() != ' ');  // Read characters until a space is encountered
    }

    iss >> utime >> stime >> cutime >> cstime;;
    long clockTicksPerSecond = sysconf(_SC_CLK_TCK);
    long totalTime = utime + stime + cutime + cstime;

    // Calculate the total CPU time in milliseconds
    double totalTimeMilliseconds = (totalTime) * 1000.0 / clockTicksPerSecond;
    statFile.close();

    return (long)totalTimeMilliseconds;
}

ThreadInfo GetThreadInfo(int processId, int threadId) {
    std::string procPath = "/proc/" + std::to_string(processId) + "/task/" + std::to_string(threadId);
    ThreadInfo threadInfo;

    try {
    std::string statPath = procPath + "/stat";
    std::ifstream statFile(statPath);
    std::string statContent;
    std::getline(statFile, statContent);
    statFile.close();

    std::istringstream statStream(statContent);
    statStream >> threadInfo.TID >> threadInfo.Name >> threadInfo.State;

    threadInfo.CPULoad = getThreadCpuTime(processId, threadId);
    threadInfo.Nice = GetThreadPriority(threadId, threadId);
    threadInfo.Priority = 0; // Thread priority in stat file (adjust accordingly)
    } catch (const std::exception& e) {
    // Handle exceptions
    }

    return threadInfo;
}
