#include <iostream>
#include <fstream>
#include <sstream>
#include <limits>
#include <string>

struct ThreadInfo {
    int TID;
    std::string Name;
    std::string State;
    int CPULoad;
    int Nice;
    int Priority;
};

ThreadInfo GetThreadInfo(int pid, int tid) {
    std::string procPath = "/proc/" + std::to_string(pid) + "/task/" + std::to_string(tid);
    ThreadInfo threadInfo;

    try {
        // Read thread name from status file
        std::ifstream statusFile(procPath + "/status");
        std::string line;
        while (std::getline(statusFile, line)) {
            if (line.find("Name:") == 0) {
                std::istringstream iss(line);
                std::string name;
                iss >> name >> std::ws;
                std::getline(iss, threadInfo.Name);
                break;
            }
        }

        // Read other thread information from stat file
        std::ifstream statFile(procPath + "/stat");
        std::string statContent;
        std::getline(statFile, statContent);
        statFile.close();

        std::istringstream statStream(statContent);
        statStream >> threadInfo.TID >> threadInfo.Name >> threadInfo.State;

        // Get thread priority
        std::string statPath = procPath + "/stat";
        statFile.open(statPath);
        std::string statLine;
        while (std::getline(statFile, statLine)) {
            if (statLine.find(") ") != std::string::npos) {
                std::istringstream iss(statLine.substr(statLine.find(") ") + 2));
                int nice, priority;
                for (int i = 0; i < 15; ++i) {
                    iss.ignore(std::numeric_limits<std::streamsize>::max(), ' ');
                }
                iss >> priority >> nice;
                threadInfo.Nice = nice;
                break;
            }
        }
        statFile.close();

        // Get thread CPU time
        statFile.open(procPath + "/stat");
        if (!statFile.is_open()) {
            std::cerr << "Error opening stat file for thread " << tid << std::endl;
            return threadInfo;
        }

        std::getline(statFile, statContent);
        statFile.close();

        std::istringstream statTimeStream(statContent);
        long utime, stime, cutime, cstime;
        for (int i = 0; i < 13; ++i) {
            while (statTimeStream.get() != ' ');
        }
        statTimeStream >> utime >> stime >> cutime >> cstime;
        long clockTicksPerSecond = sysconf(_SC_CLK_TCK);
        long totalTime = utime + stime + cutime + cstime;
        double totalTimeMilliseconds = (totalTime) * 1000.0 / clockTicksPerSecond;
        threadInfo.CPULoad = static_cast<int>(totalTimeMilliseconds);

        threadInfo.Priority = 0; // Thread priority in stat file (adjust accordingly)
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }

    return threadInfo;
}
